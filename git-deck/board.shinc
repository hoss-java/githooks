# Handling board commands: ls, mk, rm
board() {
    GIT_ROOT="$(git rev-parse --show-toplevel)"
    DECK_DIR="$GIT_ROOT/.pm/deck"
    TEMPLATES_DIR="$GIT_ROOT/.pm/templates"
    DEFAULT_BOARD_FILE="$DECK_DIR/.default"
    BOARD_HELP="$GIT_ROOT/.git/hooks/deck/board.help"

    case "$1" in
        help)
            # Check if the help file exists and print its content
            if [ -f "$BOARD_HELP" ]; then
                cat "$BOARD_HELP"
            else
                echo "Error: Help file $BOARD_HELP not found."
            fi
            ;;
        ls)
            ls_boards "${@:2}"
            ;;
        mk)
            mk_board "${@:2}"
            ;;
        set)
            set_board "${@:2}"
            ;;
        rm)
            rm_board "${@:2}"
            ;;
        cleanup)
            cleanup "${@:2}"
            ;;        
        *)
            echo "Invalid board command. Usage: git deck board {help|ls|mk|set|rm|cleanup}"
            ;;
    esac
}

# List all board directories within .pm/deck/
ls_boards() {
    return_value=1

    # Default values for options
    option_output='full'
    option_type='board'
    # Parse options using getopts
    while getopts ":o:t:-:" opt; do
        case $opt in
            o)
                option_output="$OPTARG"
                ;;
            -)
                case "${OPTARG}" in
                    output)
                        option_output="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    type)
                        option_type="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    *)
                        echo "Invalid option: --${OPTARG}" >&2
                        return 1
                        ;;
                esac
                ;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                return 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                return 1
                ;;
        esac
    done
    option_output=$(echo "$option_output" | tr '[:upper:]' '[:lower:]')

    if [ -d "$DECK_DIR" ]; then
        [ "$option_output" == 'full' ] && \
            echo "Boards:"

        SELECTED_ID=""
        [ -f "$DEFAULT_BOARD_FILE" ] && SELECTED_ID=$(cat "$DEFAULT_BOARD_FILE")
        if [ "$option_type" == 'template' ]; then
            for template in "$TEMPLATES_DIR/board"/*; do
                if [ -d "$template" ] ; then
                    TEMPLATE_NAME=$(basename "$template")
                    echo "$TEMPLATE_NAME"
                    return_value=0
                fi
            done
        elif [ "$option_type" == 'board' ]; then
            for board in "$DECK_DIR"/*; do
                if [ -d "$board" ] && [ -f "$board/.id" ]; then
                    BOARD_NAME=$(basename "$board")
                    BOARD_ID=$(cat "$board/.id")

                    if [ "$option_output" == 'id' ]; then
                        echo "$BOARD_ID"
                    elif [ "$option_output" == 'name' ]; then
                        echo "$BOARD_NAME"
                    else
                        if [ "$BOARD_ID" = "$SELECTED_ID" ]; then
                            echo " $BOARD_ID: $BOARD_NAME (Selected)"
                        else
                            echo " $BOARD_ID: $BOARD_NAME"
                        fi
                    fi
                    return_value=0
                fi
            done
        fi
    else
        [ "$option_output" == 'full' ] && \
            echo "No boards found."
    fi
    return $return_value
}

# Create a new board directory with a unique ID
mk_board() {
    return_value=1
    if [ -z "$1" ]; then
        echo "Error: No board name provided."
        return 1
    fi

    # Check if the board with the same name already exists
    if [ -d "$DECK_DIR/$1" ]; then
        echo "Error: A board with the name '$1' already exists."
        return 1
    fi

    BOARD_NAME="$1"
    shift 1 # Shift past the first two parameters

    # Default values for options
    option_template='default'
    # Parse options using getopts
    while getopts ":t:-:" opt; do
        case $opt in
            o)
                option_output="$OPTARG"
                ;;
            -)
                case "${OPTARG}" in
                    template)
                        option_output="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    *)
                        echo "Invalid option: --${OPTARG}" >&2
                        return 1
                        ;;
                esac
                ;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                return 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                return 1
                ;;
        esac
    done


    # Scan for existing IDs in board directories
    existing_ids=$(find "$DECK_DIR" -mindepth 1 -maxdepth 1 -type d -exec test -e '{}/.id' \; -print | \
        xargs -I {} cat '{}/.id' 2>/dev/null | sort -n)

    # Find the first available ID
    NEW_ID=1
    while echo "$existing_ids" | grep -q "^$NEW_ID$"; do
        NEW_ID=$((NEW_ID + 1))
    done

    # Ensure the ID is a three-digit number; max is 999
    if [ "$NEW_ID" -gt 999 ]; then
        echo "Error: Maximum number of boards (1000) reached."
        return 1
    fi

    # Create the new board directory
    mkdir -p "$DECK_DIR/$BOARD_NAME"
    # Copy templates to the board if it is available
    BOARD_TEMPLATE=$TEMPLATES_DIR/board/$option_template
    if [ -d "$BOARD_TEMPLATE" ]; then
        cp -r "$BOARD_TEMPLATE/"{.,}* "$DECK_DIR/$BOARD_NAME/"
    fi

    # Create the .id file with the new board ID inside the board directory
    echo "$NEW_ID" > "$DECK_DIR/$BOARD_NAME/.id"
    return_value=$?

    # Set the new board as the default selected board
    echo "$NEW_ID" > "$DEFAULT_BOARD_FILE"

    echo "Board '$BOARD_NAME' created with ID '$NEW_ID'."

    return $return_value
}

# Remove a board directory and its ID mapping
rm_board() {
    return_value=1
    if [ -z "$1" ]; then
        echo "Error: No board name provided."
        return 1
    fi

    BOARD_NAME="$1"
    shift 1 # Shift past the first two parameters

    # Default values for options
    option_remove='bin'
    # Parse options using getopts
    while getopts ":r:-:" opt; do
        case $opt in
            o)
                option_remove="$OPTARG"
                ;;
            -)
                case "${OPTARG}" in
                    remove)
                        option_remove="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    *)
                        echo "Invalid option: --${OPTARG}" >&2
                        return 1
                        ;;
                esac
                ;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                return 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                return 1
                ;;
        esac
    done
    option_remove=$(echo "$option_remove" | tr '[:upper:]' '[:lower:]')

    BOARD_DIR="$DECK_DIR/$BOARD_NAME"

    # Check if the board directory exists
    if [ -d "$BOARD_DIR" ]; then
        read -p "Are you sure you want to remove the board '$BOARD_NAME' ? (y/n): " answer

        if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
            # Read the ID from the .id file
            if [ -f "$BOARD_DIR/.id" ]; then
                if [ "$option_remove" == 'permanent' ]; then
                    BOARD_ID=$(cat "$BOARD_DIR/.id")
                    rm -r "$BOARD_DIR"
                    return_value=$?
                    echo "Board '$BOARD_NAME' with ID '$BOARD_ID' removed."
                else
                    BIN_FOLDER="$DECK_DIR/.bin"
                    if [ ! -d "$BIN_FOLDER" ]; then
                        mkdir -p "$BIN_FOLDER"
                    fi
                    mv "$BOARD_DIR" "$BIN_FOLDER"
                    return_value=$?
                    echo "Board '$BOARD_NAME' with ID '$BOARD_ID' was moved to '$BIN_FOLDER'."
                fi
                # Check if this board was the default and reset it if necessary
                if [ -f "$DEFAULT_BOARD_FILE" ] && [ "$(cat "$DEFAULT_BOARD_FILE")" = "$BOARD_ID" ]; then
                    echo "Default board was deleted. No active board is selected."
                    rm "$DEFAULT_BOARD_FILE"
                    return_value=$?
                fi
            else
                echo "Error: No .id file found for board '$BOARD_NAME'."
            fi
        fi
    else
        echo "Error: Board '$BOARD_NAME' does not exist."
    fi
    return $return_value
}

# Set a board as default board
set_board() {
    return_value=1
    if [ -z "$1" ]; then
        echo "Error: No board name provided to set as active."
        return 1
    fi

    BOARD_NAME="$1"
    BOARD_DIR="$DECK_DIR/$BOARD_NAME"

    # Check if the board directory exists
    if [ -d "$BOARD_DIR" ] && [ -f "$BOARD_DIR/.id" ]; then
        BOARD_ID=$(cat "$BOARD_DIR/.id")
        echo "$BOARD_ID" > "$DEFAULT_BOARD_FILE"
        return_value=$?
        echo "Board '$BOARD_NAME' with ID '$BOARD_ID' is now set as the active board."
    fi
    return $return_value
}

# Cleanup boards .bin folders
cleanup() {
    return_value=1
    BIN_FOLDER="$DECK_DIR/.bin"
    read -p "Are you sure you want to clean up the boards' bin ('$BIN_FOLDER')? (y/n): " answer

    if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
        if [ -d "$BIN_FOLDER" ]; then
            rm -r "$BIN_FOLDER"
            return_value=$?
            echo "'$BIN_FOLDER' was removed."
        fi
    fi
    rerun $return_value
}