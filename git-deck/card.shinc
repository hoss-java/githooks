# Handling card commands: ls, mk, edit, rm
card() {
    GIT_ROOT="$(git rev-parse --show-toplevel)"
    CARD_HELP="$GIT_ROOT/.git/hooks/deck/card.help"
    DECK_DIR="$GIT_ROOT/.pm/deck"
    DEFAULT_BOARD_FILE="$DECK_DIR/.default"
    DEFAULT_BOARD=-1
    DEFAULT_BOARD_NAME=''
    DEFAULT_COLUMN_FILE=''
    DEFAULT_COLUMN=-1
    DEFAULT_COLUMN_NAME=''

    if [ ! -f "$DEFAULT_BOARD_FILE" ]; then
        echo "No active board selected."
    else
        DEFAULT_BOARD=$(cat "$DEFAULT_BOARD_FILE")

        # Search for the board directory with the matching ID
        for board in "$DECK_DIR"/*; do
            if [ -d "$board" ] && [ -f "$board/.id" ]; then
                BOARD_ID=$(cat "$board/.id")
                if [ "$BOARD_ID" = "$DEFAULT_BOARD" ]; then
                    DEFAULT_BOARD_NAME=$(basename "$board")
                    DEFAULT_COLUMN_FILE="$DECK_DIR/$DEFAULT_BOARD_NAME/.default"
                    if [ ! -f "$DEFAULT_COLUMN_FILE" ]; then
                        echo "No active column selected."
                    else
                        DEFAULT_COLUMN=$(cat "$DEFAULT_COLUMN_FILE")
                        # Search for the column directory with the matching ID
                        for column in "$DECK_DIR/$DEFAULT_BOARD_NAME"/*; do
                            if [ -d "$column" ] && [ -f "$column/.id" ]; then
                                COLUMN_ID=$(cat "$column/.id")
                                if [ "$COLUMN_ID" = "$DEFAULT_COLUMN" ]; then
                                    DEFAULT_COLUMN_NAME=$(basename "$column")
                                    DEFAULT_COLUMN_FILE="$DECK_DIR/$DEFAULT_BOARD_NAME/$DEFAULT_COLUMN_NAME/.default"
                                fi
                            fi
                        done
                    fi
                fi
            fi
        done
    fi


    case "$1" in
        help)
            # Check if the help file exists and print its content
            if [ -f "$CARD_HELP" ]; then
                cat "$CARD_HELP"
            else
                echo "Error: Help file $CARD_HELP not found."
            fi
            ;;
        ls)
            [ "$DEFAULT_BOARD" -gt -1 ] && \
                [ -n "$DEFAULT_BOARD_NAME" ] && \
                ls_cards "${@:2}"
            ;;
        find)
            [ "$DEFAULT_BOARD" -gt -1 ] && \
                [ -n "$DEFAULT_BOARD_NAME" ] && \
                find_cards "${@:2}"
            ;;

        mk)
            [ "$DEFAULT_COLUMN" -gt -1 ] && \
                [ -n "$DEFAULT_COLUMN_NAME" ] && \
                mk_card "${@:2}"
            ;;
        edit)
            [ "$DEFAULT_BOARD" -gt -1 ] && \
                [ -n "$DEFAULT_BOARD_NAME" ] && \
                edit_card "${@:2}"
            ;;
        cat)
            [ "$DEFAULT_BOARD" -gt -1 ] && \
                [ -n "$DEFAULT_BOARD_NAME" ] && \
                cat_card "${@:2}"
            ;;
        set)
            [ "$DEFAULT_BOARD" -gt -1 ] && \
                [ -n "$DEFAULT_BOARD_NAME" ] && \
                set_card "${@:2}"
            ;;
        mv)
            [ "$DEFAULT_BOARD" -gt -1 ] && \
                [ -n "$DEFAULT_BOARD_NAME" ] && \
                mv_card "${@:2}"
            ;;
        rm)
            [ "$DEFAULT_BOARD" -gt -1 ] && \
                [ -n "$DEFAULT_BOARD_NAME" ] && \
                rm_card "${@:2}"
            ;;
        cleanup)
            cleanup "${@:2}"
            ;;
        *)
            echo "Invalid card command. Usage: git deck card {help|ls|find|mk|edit|cat|set|mv|rm|cleanup}"
            ;;
    esac
}

# exteract header from a card
extract_card_headers() {
    local file="$1"
    declare -A headers

    # Extract the header into a variable
    header=$(awk '
        BEGIN { in_header=0 }
        /^---/ {
            in_header=1-in_header; 
            if (in_header == 0) exit # Exit after the second ---
            next # Skip the --- lines
        }
        in_header && length($0) > 0 { print }
    ' "$file")

    # Process each line of the header
    while IFS= read -r line; do
        if [[ ! -z "$line" ]]; then
            key=$(echo "$line" | cut -d':' -f1 | xargs)
            value=$(echo "$line" | cut -d':' -f2- | xargs)
            if [[ -n "$key" ]]; then
                headers["$key"]="$value"
            fi
        fi
    done <<< "$header"

    # Return the associative array
    echo "$(declare -p headers)"
}

# Function to split a string into key-value pairs and free text
split_string() {
    local input_string="$1"
    local IFS=',,'
    read -ra items <<< "$input_string" # Split based on the specified delimiters

    declare -A kv_pairs # Declare an associative array for key-value pairs

    for item in "${items[@]}"; do
        if [[ "$item" == *"="* ]]; then
            # Split key and value
            key="${item%%=*}"
            value="${item#*=}"

            # Format the key: trim spaces and replace spaces with dashes
            key=$(echo "$key" | xargs | sed 's/ /-/g') 
            value=$(echo "$value" | xargs) # Trim leading and trailing spaces
            kv_pairs["$key"]="$value" # Store in associative array
        else
            # Trim the free text and append to the "freetext" key
            trimmed_item=$(echo "$item" | xargs) # Trim leading and trailing spaces
            # Ensure there's no extra space at the end of free text
            kv_pairs["freetext"]+="$trimmed_item" # Append free text
        fi
    done

    # Output the associative array
    echo "$(declare -p kv_pairs)"
}

# Search for cards on the current default board
find_cards() {
    return_value=1
    if [ -z "$1" ]; then
        echo "Error: No search string provided."
        return $return_value
    fi

    SEARCH_STRING="$1"
    shift 1 # Shift past the first two parameters

    eval $(split_string "$SEARCH_STRING")

    # Default values for options
    option_output='full'
    option_match='partial'
    # Parse options using getopts
    while getopts ":o:m:-:" opt; do
        case $opt in
            o)
                option_output="$OPTARG"
                ;;
            o)
                option_match="$OPTARG"
                ;;
            -)
                case "${OPTARG}" in
                    output)
                        option_output="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    match)
                        option_match="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    *)
                        echo "Invalid option: --${OPTARG}" >&2
                        return 1
                        ;;
                esac
                ;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                return 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                return 1
                ;;
        esac
    done
    option_output=$(echo "$option_output" | tr '[:upper:]' '[:lower:]')
    option_match=$(echo "$option_match" | tr '[:upper:]' '[:lower:]')


    if [ "$option_output" == 'full' ]; then
        echo "Found cards:"
    fi

    for card in "$DECK_DIR"/$DEFAULT_BOARD_NAME/*/*; do
        if [ -f "$card" ]; then
            CARD_NAME=$(basename "$card")
            CARD_PATH=$(dirname "$card")
            CARD_COLUNM=$(basename "$(dirname "$card")")
            if [[ "$CARD_NAME" =~ ^[0-9]{1,4}$ ]]; then
                eval "$(extract_card_headers "$card")"
                # Initialize a flag to determine if all headers are matched
                local all_matched=false

                for header_key in "${!headers[@]}"; do
                    header_value="${headers[$header_key]}"
                    header_key=$(echo "$header_key" | xargs | tr '[:upper:]' '[:lower:]') # Trim whitespace and convert to lowercase
                    header_key_lower=$(echo "$header_key" | tr '[:upper:]' '[:lower:]')
                    header_value_lower=$(echo "$header_value" | tr '[:upper:]' '[:lower:]')

                    local found=false # Flag to determine if the header is found

                    for search_key in "${!kv_pairs[@]}"; do
                        search_value="${kv_pairs[$search_key]}"
                        # Convert key and value to lowercase for comparison
                        search_key_lower=$(echo "$search_key" | tr '[:upper:]' '[:lower:]')
                        search_value_lower=$(echo "$search_value" | tr '[:upper:]' '[:lower:]')

                        # Check if the key is 'freetext', continue to next iteration if it is
                        if [[ "$search_key_lower" == "freetext" ]]; then
                            continue
                        fi

                        if [ "$search_key_lower" == "$header_key_lower" ]; then
                            if [ "$option_match" == 'full' ]; then
                                if [[ "$header_value_lower" == "$search_value_lower" ]]; then
                                    found=true
                                fi
                            elif [[ "$header_value_lower" == *"$search_value_lower"* ]]; then
                                found=true
                            fi

                            if [ "$found" == true ]; then
                                break # Break inner loop if a match is found
                            fi
                        fi
                    done

                    if $found; then
                        all_matched=true # Set the flag if any header is not found
                        break # No need to check further if one isn't found
                    fi
                done

                if $all_matched == true; then
                    card_title=''
                    if [ ${#headers[@]} -eq 0 ]; then
                        card_title="**No title found**"
                    else
                        # Access the title in a case-insensitive manner
                        for k in "${!headers[@]}"; do
                            if [[ "${k,,}" == "title" ]]; then # Convert key to lowercase for comparison
                                card_title="${headers[$k]}"
                                break
                            fi
                        done
                    fi

                    CARD_ID=$((10#$CARD_NAME))
                    DEFAULT_CARD_FILE=$CARD_PATH/.default
                    selected_text=''
                    if [ -f "$DEFAULT_CARD_FILE" ]; then 
                        SELECTED_ID=$(cat "$DEFAULT_CARD_FILE")
                        if [ "$CARD_ID" = "$SELECTED_ID" ]; then
                            selected_text='(Selected)'
                        fi
                    fi

                    if [ "$option_output" == 'short' ]; then
                        echo "$CARD_NAME"
                    elif [ "$option_output" == 'notitle' ]; then
                        echo "$DEFAULT_BOARD_NAME/$CARD_COLUNM/$CARD_NAME"
                    else
                        echo " $DEFAULT_BOARD_NAME/$CARD_COLUNM/$CARD_NAME - $card_title $selected_text"
                    fi
                    return_value=0
                fi

            fi
        fi
    done
    return $return_value
}

# List all cards within .pm/deck/<default-board>/
ls_cards() {
    return_value=1

    # Default values for options
    option_output='full'
    option_column='*'
    # Parse options using getopts
    while getopts ":o:c:-:" opt; do
        case $opt in
            o)
                option_output="$OPTARG"
                ;;
            -)
                case "${OPTARG}" in
                    output)
                        option_output="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    column)
                        option_column="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    *)
                        echo "Invalid option: --${OPTARG}" >&2
                        return 1
                        ;;
                esac
                ;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                return 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                return 1
                ;;
        esac
    done
    option_output=$(echo "$option_output" | tr '[:upper:]' '[:lower:]')

    if [ "$option_output" == 'full' ]; then
        echo "Cards:"
    fi

    for card in "$DECK_DIR"/$DEFAULT_BOARD_NAME/$option_column/*; do
        if [ -f "$card" ]; then
            CARD_NAME=$(basename "$card")
            CARD_PATH=$(dirname "$card")
            CARD_COLUNM=$(basename "$(dirname "$card")")
            if [[ "$CARD_NAME" =~ ^[0-9]{1,4}$ ]]; then
                eval "$(extract_card_headers "$card")"
                # Access the headers with the returned associative array
                card_title=''
                if [ ${#headers[@]} -eq 0 ]; then
                    card_title="**No title found**"
                else
                    # Access the title in a case-insensitive manner
                    for k in "${!headers[@]}"; do
                        if [[ "${k,,}" == "title" ]]; then # Convert key to lowercase for comparison
                            card_title="${headers[$k]}"
                            break
                        fi
                    done
                fi
                CARD_ID=$((10#$CARD_NAME))
                DEFAULT_CARD_FILE=$CARD_PATH/.default
                selected_text=''
                if [ -f "$DEFAULT_CARD_FILE" ]; then 
                    SELECTED_ID=$(cat "$DEFAULT_CARD_FILE")
                    SELECTED_ID=$((10#$SELECTED_ID))
                    if [ "$CARD_ID" = "$SELECTED_ID" ]; then
                        selected_text='(Selected)'
                    fi
                fi

                if [ "$option_output" == 'short' ]; then
                    echo "$CARD_NAME"
                elif [ "$option_output" == 'notitle' ]; then
                    echo "$DEFAULT_BOARD_NAME/$CARD_COLUNM/$CARD_NAME"
                else
                    echo " $DEFAULT_BOARD_NAME/$CARD_COLUNM/$CARD_NAME - $card_title $selected_text"
                fi
                return_value=0
            fi
        fi
    done

    return $return_value
}

# Create a new card on the current default column of the selected board
mk_card() {
    return_value=1
    # Open/Create the new card at <default-board>/<default-column>
    DEFAULT_EDITOR=nano
    EDITOR=${EDITOR:-$DEFAULT_EDITOR}

    ([ "$DEFAULT_COLUMN" -lt 1 ] || [ -z "$DEFAULT_COLUMN_FILE" ]) && \
        echo "Error: No column selected." && \
        return $return_value

    if [ -z "$1" ]; then
        echo "Error: No card title provided."
        return $return_value
    fi
    CARD_TITLE="$1"

    search_output=$(find_cards "title=$CARD_TITLE" --output notitle --match full)
    if [ $? == 0 ]; then
        # Get the first line
        first_line=$(echo "$search_output" | head -n 1)
        echo "There is a card exact with the same title, '$first_line'"
        read -p "Do you want to Edit it instead to create a new one? (y/n): " answer

        if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
            $DEFAULT_EDITOR $DECK_DIR/$first_line
            return_value=$?
            return $return_value
        fi
    fi

    # Scan for existing IDs in board directories
    existing_ids=$(find "$DECK_DIR/$DEFAULT_BOARD_NAME" -mindepth 1 -maxdepth 2 -type f -printf "%f\n" | \
        awk '{print $1+0}' | awk '$1 != 0' | sort -n)

    # Find the first available ID
    NEW_ID=1
    while echo "$existing_ids" | grep -q "^$NEW_ID$"; do
        NEW_ID=$((NEW_ID + 1))
    done

    # Ensure the ID is a three-digit number; max is 999
    if [ "$NEW_ID" -gt 9999 ]; then
        echo "Error: Maximum number of cards (10000) reached."
        return $return_value
    fi

    # Look for a card template
    CARD_TEMPLATE="$DECK_DIR/$DEFAULT_BOARD_NAME/$DEFAULT_COLUMN_NAME/default-card"
    NEW_CARD_FILE="$DECK_DIR/$DEFAULT_BOARD_NAME/$DEFAULT_COLUMN_NAME/$(printf "%04d" "$NEW_ID")"
    if [ -f "$CARD_TEMPLATE" ]; then
        cp "$CARD_TEMPLATE" "$NEW_CARD_FILE"
        # Use sed to replace %TITLE% with the new title
        sed -i "s/%TITLE%/$CARD_TITLE/g" "$NEW_CARD_FILE"
    else
        {
            echo "---"
            echo "Title: $CARD_TITLE"
            echo "Tags:"
            echo "---"
        } > "$NEW_CARD_FILE"
    fi

    $DEFAULT_EDITOR $NEW_CARD_FILE
    return_value=$?
    return $return_value
}

# Edit a card from the current default board
edit_card() {
    return_value=1

    if [ -z "$1" ]; then
        echo "Error: No car id provided to open."
        return $return_value
    fi

    CARD_ID="$1"
    shift 1 # Shift past the first two parameters

    # Default values for options
    option_editor="nano"
    # Parse options using getopts
    while getopts ":e:-:" opt; do
        case $opt in
            e)
                option_editor="$OPTARG"
                ;;
            -)
                case "${OPTARG}" in
                    editor)
                        option_editor="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    *)
                        echo "Invalid option: --${OPTARG}" >&2
                        return 1
                        ;;
                esac
                ;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                return 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                return 1
                ;;
        esac
    done
    option_editor=$(echo "$option_editor" | tr '[:upper:]' '[:lower:]')

    for card in "$DECK_DIR"/$DEFAULT_BOARD_NAME/*/$(printf "%04d" "$CARD_ID"); do
        if [ -f "$card" ]; then
            DEFAULT_EDITOR="$option_editor"
            EDITOR=${EDITOR:-$DEFAULT_EDITOR}
            $DEFAULT_EDITOR "$card"
            return_value=$?
            break
        else
            echo "Error: No card with id '$CARD_ID' found for column '$DEFAULT_BOARD_NAME'."
        fi
    done
    return $return_value
}

# Cat a card from the current default board
cat_card() {
    return_value=1

    if [ -z "$1" ]; then
        echo "Error: No card id provided."
        return $return_value
    fi

    CARD_ID="$1"
    for card in "$DECK_DIR"/$DEFAULT_BOARD_NAME/*/$(printf "%04d" "$CARD_ID"); do
        if [ -f "$card" ]; then
            cat "$card"
            return_value=$?
            break
        else
            echo "Error: No card with id '$CARD_ID' found for column '$DEFAULT_BOARD_NAME/$DEFAULT_COLUMN_NAME'."
        fi
    done
    return $return_value
}

# Set a card as default for its column and board
set_card() {
    return_value=1

    if [ -z "$1" ]; then
        echo "Error: No card id provided to set as active."
        return $return_value
    fi

    CARD_ID="$1"
    for card in "$DECK_DIR"/$DEFAULT_BOARD_NAME/*/$(printf "%04d" "$CARD_ID"); do
        if [ -f "$card" ]; then
            CARD_NAME=$(basename "$card")
            CARD_PATH=$(dirname "$card")
            CARD_COLUNM=$(basename "$(dirname "$card")")

            DEFAULT_CARD_FILE="$DECK_DIR/$DEFAULT_BOARD_NAME/$CARD_COLUNM/.default"
            echo "$CARD_ID" > "$DEFAULT_CARD_FILE"
            return_value=$?
            echo "Card '$CARD_NAME' is now set as the active card for '$DEFAULT_BOARD_NAME/$CARD_COLUNM'."
            break
        else
            echo "Error: No card with id '$CARD_ID' found for column '$DEFAULT_BOARD_NAME'."
        fi
    done
    return $return_value
}

# Move a card to a column on the current default board
mv_card() {
    return_value=1

    if [ -z "$1" ]; then
        echo "Error: No card id provided to set as active."
        return $return_value
    fi

    CARD_ID="$1"
    COLUMN_NAME="$2"
    for card in "$DECK_DIR"/$DEFAULT_BOARD_NAME/*/$(printf "%04d" "$CARD_ID"); do
        if [ -f "$card" ]; then
            CARD_NAME=$(basename "$card")
            CARD_PATH=$(dirname "$card")
            CARD_COLUNM=$(basename "$(dirname "$card")")
            if [ "$COLUMN_NAME" != "$CARD_COLUNM" ]; then
                NEW_COLUNM="$DECK_DIR/$DEFAULT_BOARD_NAME/$COLUMN_NAME"
                if [ -d "$NEW_COLUNM" ]; then
                    mv "$card" "$NEW_COLUNM/"
                    return_value=$?
                    echo "Column '$CARD_NAME' was moved to '$NEW_COLUNM'."
                fi
            else
                echo "Column '$CARD_NAME' has been already stored in '$CARD_COLUNM'."
            fi
            break
        else
            echo "Error: No card with id '$CARD_ID' found for column '$DEFAULT_BOARD_NAME'."
        fi
    done
    return $return_value
}

# Remove a card from the current default board
rm_card() {
    return_value=1

    if [ -z "$1" ]; then
        echo "Error: No card id provided."
        return 1
    fi

    CARD_ID="$1"
    shift 1 # Shift past the first two parameters

    # Default values for options
    option_remove='bin'
    # Parse options using getopts
    while getopts ":r:-:" opt; do
        case $opt in
            o)
                option_remove="$OPTARG"
                ;;
            -)
                case "${OPTARG}" in
                    remove)
                        option_remove="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    *)
                        echo "Invalid option: --${OPTARG}" >&2
                        return 1
                        ;;
                esac
                ;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                return 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                return 1
                ;;
        esac
    done
    option_remove=$(echo "$option_remove" | tr '[:upper:]' '[:lower:]')

    for card in "$DECK_DIR"/$DEFAULT_BOARD_NAME/*/$(printf "%04d" "$CARD_ID"); do
        if [ -f "$card" ]; then
            CARD_NAME=$(basename "$card")
            CARD_PATH=$(dirname "$card")
            CARD_COLUNM=$(basename "$(dirname "$card")")

            BIN_FOLDER="$DECK_DIR/$DEFAULT_BOARD_NAME/.bin/$CARD_COLUNM"
            CARD_FILE_BIN_FOLDER="$BIN_FOLDER/$CARD_NAME"

            read -p "Are you sure you want to remove the card '$DEFAULT_BOARD_NAME/$CARD_COLUNM/$CARD_ID' ? (y/n): " answer

            if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
                if [ "$option_remove" == 'permanent' ]; then
                    rm "$card"
                    return_value=$?
                    echo "Card '$CARD_NAME' was removed."
                else
                    if [ ! -d "$BIN_FOLDER" ]; then
                        mkdir -p "$BIN_FOLDER"
                    fi
                    mv "$card" "$CARD_FILE_BIN_FOLDER"
                    return_value=$?
                    echo "Card '$CARD_NAME' was moved to '$BIN_FOLDER'."
                fi
                break
            fi            
        else
            echo "Error: No card with id '$CARD_ID' found for board '$DEFAULT_BOARD_NAME'."
        fi
    done
    return $return_value
}

# Cleanup cards/columns .bin folders
cleanup() {
    return_value=1
    BIN_FOLDER="$DECK_DIR/$DEFAULT_BOARD_NAME/.bin"
    read -p "Are you sure you want to clean up the cards'/column's bin ('$BIN_FOLDER')? (y/n): " answer

    if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
        if [ -d "$BIN_FOLDER" ]; then
            rm -r "$BIN_FOLDER"
            return_value=$?
            echo "'$BIN_FOLDER' was removed."
        fi
    fi
    rerun $return_value
}